{
  "version": 3,
  "sources": ["../src/get-otp.tsx", "../src/lib/storage.ts"],
  "sourcesContent": ["import { Action, ActionPanel, Clipboard, List, Toast, showToast, getPreferenceValues } from \"@raycast/api\";\nimport { useEffect, useState } from \"react\";\nimport type { OtpPair } from \"./lib/storage\";\nimport { loadPairs } from \"./lib/storage\";\nimport { execFile } from \"child_process\";\nimport { promisify } from \"util\";\nimport { access } from \"fs/promises\";\n\nconst execFileAsync = promisify(execFile);\n\nasync function runOpVersion(opPath: string): Promise<string> {\n  const { stdout } = await execFileAsync(opPath, [\"--version\"]);\n  return stdout.toString().trim();\n}\n\nasync function readOtp(opPath: string, ref: string): Promise<string> {\n  try {\n    const { stdout } = await execFileAsync(opPath, [\"read\", ref]);\n    return stdout.toString().trim();\n  } catch (e: any) {\n    const stderr = e?.stderr?.toString?.().trim?.();\n    throw new Error(stderr || e?.message || String(e));\n  }\n}\n\nasync function fileExists(path: string): Promise<boolean> {\n  try {\n    await access(path);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\nasync function getOpPath(): Promise<string> {\n  const prefs = getPreferenceValues<{ op_path?: string }>();\n  if (prefs?.op_path) {\n    if (await fileExists(prefs.op_path)) return prefs.op_path;\n  }\n  const candidates = [\n    \"/opt/homebrew/bin/op\",\n    \"/usr/local/bin/op\",\n    \"/usr/bin/op\",\n  ];\n  for (const c of candidates) {\n    if (await fileExists(c)) return c;\n  }\n  return \"op\";\n}\n\nexport default function Command() {\n  const [pairs, setPairs] = useState<OtpPair[] | null>(null);\n  const [checkingOp, setCheckingOp] = useState(true);\n  const [opOk, setOpOk] = useState<boolean>(false);\n  const [opPath, setOpPath] = useState<string | null>(null);\n\n  useEffect(() => {\n    (async () => {\n      try {\n        const p = await getOpPath();\n        setOpPath(p);\n        var version = await runOpVersion(p);\n        await showToast({ style: Toast.Style.Success, title: \"1Password CLI\", message: `Version: ${version}` });\n        setOpOk(true);\n      } catch (e: any) {\n        setOpOk(false);\n        await showToast({ style: Toast.Style.Failure, title: \"1Password CLI not found or not available\", message: \"Install via Homebrew or set Preferences \u2192 1Password CLI Path\" });\n      } finally {\n        setCheckingOp(false);\n      }\n    })();\n  }, []);\n\n  useEffect(() => {\n    (async () => {\n      const data = await loadPairs();\n      setPairs(data);\n    })();\n  }, []);\n\n  const isLoading = pairs === null || checkingOp;\n\n  async function handleCopy(pair: OtpPair) {\n    try {\n      if (!opOk || !opPath) throw new Error(\"1Password CLI not available\");\n      const code = await readOtp(opPath, pair.ref);\n      await Clipboard.copy(code);\n      await showToast({ style: Toast.Style.Success, title: \"OTP copied\", message: pair.label });\n    } catch (e: any) {\n      await showToast({ style: Toast.Style.Failure, title: \"Failed to get OTP\", message: e?.message ?? String(e) });\n    }\n  }\n\n  async function handlePaste(pair: OtpPair) {\n    try {\n      if (!opOk || !opPath) throw new Error(\"1Password CLI not available\");\n      const code = await readOtp(opPath, pair.ref);\n      await Clipboard.paste(code);\n      await showToast({ style: Toast.Style.Success, title: \"OTP pasted\", message: pair.label });\n    } catch (e: any) {\n      await showToast({ style: Toast.Style.Failure, title: \"Failed to paste OTP\", message: e?.message ?? String(e) });\n    }\n  }\n\n  return (\n    <List isLoading={isLoading} searchBarPlaceholder=\"Search labels...\">\n      {Array.isArray(pairs) && pairs.length === 0 ? (\n        <List.EmptyView title=\"No OTP pairs configured\" description=\"Use Manage OTP Pairs to add label/ref entries.\" actions={<EmptyActions />} />\n      ) : (\n        pairs?.map((p) => (\n          <List.Item\n            key={p.id}\n            title={p.label}\n            subtitle={p.ref}\n            actions={\n              <ActionPanel>\n                <Action title=\"Copy OTP\" onAction={() => handleCopy(p)} />\n                <Action title=\"Paste OTP to App\" onAction={() => handlePaste(p)} />\n              </ActionPanel>\n            }\n          />\n        ))\n      )}\n    </List>\n  );\n}\n\nfunction EmptyActions() {\n  return (\n    <ActionPanel>\n      <Action title=\"Open Manage OTP Pairs\" onAction={() => { }} />\n    </ActionPanel>\n  );\n}\n", "import { LocalStorage, getPreferenceValues } from \"@raycast/api\";\nimport { randomUUID } from \"crypto\";\n\nexport type OtpPair = {\n  id: string;\n  label: string;\n  ref: string;\n};\n\nconst STORAGE_KEY = \"otp_pairs\";\n\ntype Prefs = {\n  otp_pairs_seed?: string;\n};\n\nexport async function loadPairs(): Promise<OtpPair[]> {\n  const raw = await LocalStorage.getItem<string>(STORAGE_KEY);\n  if (raw) {\n    try {\n      const parsed = JSON.parse(raw) as OtpPair[];\n      return parsed.filter((p) => p && p.label && p.ref && p.id);\n    } catch {\n      return [];\n    }\n  }\n  const prefs = getPreferenceValues<Prefs>();\n  const seed = prefs.otp_pairs_seed?.trim();\n  if (!seed) return [];\n  const seeded = parseSeed(seed);\n  if (seeded.length > 0) {\n    await savePairs(seeded);\n    return seeded;\n  }\n  return [];\n}\n\nexport async function savePairs(pairs: OtpPair[]): Promise<void> {\n  const normalized = pairs.map((p) => ({ id: p.id || generateId(), label: p.label.trim(), ref: p.ref.trim() }));\n  await LocalStorage.setItem(STORAGE_KEY, JSON.stringify(normalized));\n}\n\nexport async function addPair(label: string, ref: string): Promise<OtpPair> {\n  const pairs = await loadPairs();\n  const pair: OtpPair = { id: generateId(), label: label.trim(), ref: ref.trim() };\n  pairs.push(pair);\n  await savePairs(pairs);\n  return pair;\n}\n\nexport async function updatePair(updated: OtpPair): Promise<void> {\n  const pairs = await loadPairs();\n  const idx = pairs.findIndex((p) => p.id === updated.id);\n  if (idx >= 0) {\n    pairs[idx] = { ...updated, label: updated.label.trim(), ref: updated.ref.trim() };\n    await savePairs(pairs);\n  }\n}\n\nexport async function deletePair(id: string): Promise<void> {\n  const pairs = await loadPairs();\n  const filtered = pairs.filter((p) => p.id !== id);\n  await savePairs(filtered);\n}\n\nexport function exportPairsJSON(pairs: OtpPair[]): string {\n  const minimal = pairs.map((p) => ({ label: p.label, ref: p.ref }));\n  return JSON.stringify(minimal, null, 2);\n}\n\nexport function parseSeed(text: string): OtpPair[] {\n  const trimmed = text.trim();\n  if (!trimmed) return [];\n  try {\n    const arr = JSON.parse(trimmed) as Array<{ label?: string; ref?: string }>;\n    if (Array.isArray(arr)) {\n      const pairs = arr\n        .filter((x) => x && typeof x.label === \"string\" && typeof x.ref === \"string\")\n        .map((x) => ({ id: generateId(), label: x.label!.trim(), ref: x.ref!.trim() }))\n        .filter((p) => p.label && p.ref);\n      if (pairs.length > 0) return pairs;\n    }\n  } catch {}\n  const lines = trimmed.split(/\\r?\\n/);\n  const pairs: OtpPair[] = [];\n  for (const line of lines) {\n    const m = line.match(/^\\s*(.+?)\\s*=\\s*(op:\\/\\/.*)\\s*$/);\n    if (m) {\n      const label = m[1].trim();\n      const ref = m[2].trim();\n      if (label && ref) pairs.push({ id: generateId(), label, ref });\n    }\n  }\n  return dedupeByLabel(pairs);\n}\n\nexport function mergePairs(existing: OtpPair[], incoming: OtpPair[]): OtpPair[] {\n  const byLabel = new Map(existing.map((p) => [p.label.toLowerCase(), p] as const));\n  for (const p of incoming) {\n    const key = p.label.toLowerCase();\n    if (byLabel.has(key)) {\n      const cur = byLabel.get(key)!;\n      byLabel.set(key, { ...cur, ref: p.ref });\n    } else {\n      byLabel.set(key, p);\n    }\n  }\n  return Array.from(byLabel.values());\n}\n\nfunction dedupeByLabel(pairs: OtpPair[]): OtpPair[] {\n  const seen = new Set<string>();\n  const out: OtpPair[] = [];\n  for (const p of pairs) {\n    const key = p.label.toLowerCase();\n    if (!seen.has(key)) {\n      seen.add(key);\n      out.push(p);\n    }\n  }\n  return out;\n}\n\nfunction generateId(): string {\n  try {\n    return randomUUID();\n  } catch {\n    return `${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;\n    }\n}\n"],
  "mappings": "yaAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAA4F,wBAC5FC,EAAoC,iBCDpC,IAAAC,EAAkD,wBAClDC,EAA2B,kBAQrBC,EAAc,YAMpB,eAAsBC,GAAgC,CACpD,IAAMC,EAAM,MAAM,eAAa,QAAgBF,CAAW,EAC1D,GAAIE,EACF,GAAI,CAEF,OADe,KAAK,MAAMA,CAAG,EACf,OAAQC,GAAMA,GAAKA,EAAE,OAASA,EAAE,KAAOA,EAAE,EAAE,CAC3D,MAAQ,CACN,MAAO,CAAC,CACV,CAGF,IAAMC,KADQ,uBAA2B,EACtB,gBAAgB,KAAK,EACxC,GAAI,CAACA,EAAM,MAAO,CAAC,EACnB,IAAMC,EAASC,EAAUF,CAAI,EAC7B,OAAIC,EAAO,OAAS,GAClB,MAAME,EAAUF,CAAM,EACfA,GAEF,CAAC,CACV,CAEA,eAAsBE,EAAUC,EAAiC,CAC/D,IAAMC,EAAaD,EAAM,IAAKL,IAAO,CAAE,GAAIA,EAAE,IAAMO,EAAW,EAAG,MAAOP,EAAE,MAAM,KAAK,EAAG,IAAKA,EAAE,IAAI,KAAK,CAAE,EAAE,EAC5G,MAAM,eAAa,QAAQH,EAAa,KAAK,UAAUS,CAAU,CAAC,CACpE,CA8BO,SAASE,EAAUC,EAAyB,CACjD,IAAMC,EAAUD,EAAK,KAAK,EAC1B,GAAI,CAACC,EAAS,MAAO,CAAC,EACtB,GAAI,CACF,IAAMC,EAAM,KAAK,MAAMD,CAAO,EAC9B,GAAI,MAAM,QAAQC,CAAG,EAAG,CACtB,IAAMC,EAAQD,EACX,OAAQE,GAAMA,GAAK,OAAOA,EAAE,OAAU,UAAY,OAAOA,EAAE,KAAQ,QAAQ,EAC3E,IAAKA,IAAO,CAAE,GAAIC,EAAW,EAAG,MAAOD,EAAE,MAAO,KAAK,EAAG,IAAKA,EAAE,IAAK,KAAK,CAAE,EAAE,EAC7E,OAAQE,GAAMA,EAAE,OAASA,EAAE,GAAG,EACjC,GAAIH,EAAM,OAAS,EAAG,OAAOA,CAC/B,CACF,MAAQ,CAAC,CACT,IAAMI,EAAQN,EAAQ,MAAM,OAAO,EAC7BE,EAAmB,CAAC,EAC1B,QAAWK,KAAQD,EAAO,CACxB,IAAME,EAAID,EAAK,MAAM,iCAAiC,EACtD,GAAIC,EAAG,CACL,IAAMC,EAAQD,EAAE,CAAC,EAAE,KAAK,EAClBE,EAAMF,EAAE,CAAC,EAAE,KAAK,EAClBC,GAASC,GAAKR,EAAM,KAAK,CAAE,GAAIE,EAAW,EAAG,MAAAK,EAAO,IAAAC,CAAI,CAAC,CAC/D,CACF,CACA,OAAOC,EAAcT,CAAK,CAC5B,CAgBA,SAASU,EAAcC,EAA6B,CAClD,IAAMC,EAAO,IAAI,IACXC,EAAiB,CAAC,EACxB,QAAWC,KAAKH,EAAO,CACrB,IAAMI,EAAMD,EAAE,MAAM,YAAY,EAC3BF,EAAK,IAAIG,CAAG,IACfH,EAAK,IAAIG,CAAG,EACZF,EAAI,KAAKC,CAAC,EAEd,CACA,OAAOD,CACT,CAEA,SAASG,GAAqB,CAC5B,GAAI,CACF,SAAO,cAAW,CACpB,MAAQ,CACN,MAAO,GAAG,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,EAAG,EAAE,CAAC,EAC/D,CACJ,CD5HA,IAAAC,EAAyB,yBACzBC,EAA0B,gBAC1BC,EAAuB,uBAqGuGC,EAAA,6BAnGxHC,KAAgB,aAAU,UAAQ,EAExC,eAAeC,EAAaC,EAAiC,CAC3D,GAAM,CAAE,OAAAC,CAAO,EAAI,MAAMH,EAAcE,EAAQ,CAAC,WAAW,CAAC,EAC5D,OAAOC,EAAO,SAAS,EAAE,KAAK,CAChC,CAEA,eAAeC,EAAQF,EAAgBG,EAA8B,CACnE,GAAI,CACF,GAAM,CAAE,OAAAF,CAAO,EAAI,MAAMH,EAAcE,EAAQ,CAAC,OAAQG,CAAG,CAAC,EAC5D,OAAOF,EAAO,SAAS,EAAE,KAAK,CAChC,OAASG,EAAQ,CACf,IAAMC,EAASD,GAAG,QAAQ,WAAW,EAAE,OAAO,EAC9C,MAAM,IAAI,MAAMC,GAAUD,GAAG,SAAW,OAAOA,CAAC,CAAC,CACnD,CACF,CAEA,eAAeE,EAAWC,EAAgC,CACxD,GAAI,CACF,eAAM,UAAOA,CAAI,EACV,EACT,MAAQ,CACN,MAAO,EACT,CACF,CAEA,eAAeC,GAA6B,CAC1C,IAAMC,KAAQ,uBAA0C,EACxD,GAAIA,GAAO,SACL,MAAMH,EAAWG,EAAM,OAAO,EAAG,OAAOA,EAAM,QAEpD,IAAMC,EAAa,CACjB,uBACA,oBACA,aACF,EACA,QAAWC,KAAKD,EACd,GAAI,MAAMJ,EAAWK,CAAC,EAAG,OAAOA,EAElC,MAAO,IACT,CAEe,SAARC,GAA2B,CAChC,GAAM,CAACC,EAAOC,CAAQ,KAAI,YAA2B,IAAI,EACnD,CAACC,EAAYC,CAAa,KAAI,YAAS,EAAI,EAC3C,CAACC,EAAMC,CAAO,KAAI,YAAkB,EAAK,EACzC,CAAClB,EAAQmB,CAAS,KAAI,YAAwB,IAAI,KAExD,aAAU,IAAM,EACb,SAAY,CACX,GAAI,CACF,IAAMC,EAAI,MAAMZ,EAAU,EAC1BW,EAAUC,CAAC,EACX,IAAIC,EAAU,MAAMtB,EAAaqB,CAAC,EAClC,QAAM,aAAU,CAAE,MAAO,QAAM,MAAM,QAAS,MAAO,gBAAiB,QAAS,YAAYC,CAAO,EAAG,CAAC,EACtGH,EAAQ,EAAI,CACd,MAAiB,CACfA,EAAQ,EAAK,EACb,QAAM,aAAU,CAAE,MAAO,QAAM,MAAM,QAAS,MAAO,2CAA4C,QAAS,mEAA+D,CAAC,CAC5K,QAAE,CACAF,EAAc,EAAK,CACrB,CACF,GAAG,CACL,EAAG,CAAC,CAAC,KAEL,aAAU,IAAM,EACb,SAAY,CACX,IAAMM,EAAO,MAAMC,EAAU,EAC7BT,EAASQ,CAAI,CACf,GAAG,CACL,EAAG,CAAC,CAAC,EAEL,IAAME,EAAYX,IAAU,MAAQE,EAEpC,eAAeU,EAAWC,EAAe,CACvC,GAAI,CACF,GAAI,CAACT,GAAQ,CAACjB,EAAQ,MAAM,IAAI,MAAM,6BAA6B,EACnE,IAAM2B,EAAO,MAAMzB,EAAQF,EAAQ0B,EAAK,GAAG,EAC3C,MAAM,YAAU,KAAKC,CAAI,EACzB,QAAM,aAAU,CAAE,MAAO,QAAM,MAAM,QAAS,MAAO,aAAc,QAASD,EAAK,KAAM,CAAC,CAC1F,OAAStB,EAAQ,CACf,QAAM,aAAU,CAAE,MAAO,QAAM,MAAM,QAAS,MAAO,oBAAqB,QAASA,GAAG,SAAW,OAAOA,CAAC,CAAE,CAAC,CAC9G,CACF,CAEA,eAAewB,EAAYF,EAAe,CACxC,GAAI,CACF,GAAI,CAACT,GAAQ,CAACjB,EAAQ,MAAM,IAAI,MAAM,6BAA6B,EACnE,IAAM2B,EAAO,MAAMzB,EAAQF,EAAQ0B,EAAK,GAAG,EAC3C,MAAM,YAAU,MAAMC,CAAI,EAC1B,QAAM,aAAU,CAAE,MAAO,QAAM,MAAM,QAAS,MAAO,aAAc,QAASD,EAAK,KAAM,CAAC,CAC1F,OAAStB,EAAQ,CACf,QAAM,aAAU,CAAE,MAAO,QAAM,MAAM,QAAS,MAAO,sBAAuB,QAASA,GAAG,SAAW,OAAOA,CAAC,CAAE,CAAC,CAChH,CACF,CAEA,SACE,OAAC,QAAK,UAAWoB,EAAW,qBAAqB,mBAC9C,eAAM,QAAQX,CAAK,GAAKA,EAAM,SAAW,KACxC,OAAC,OAAK,UAAL,CAAe,MAAM,0BAA0B,YAAY,iDAAiD,WAAS,OAACgB,EAAA,EAAa,EAAI,EAExIhB,GAAO,IAAKO,MACV,OAAC,OAAK,KAAL,CAEC,MAAOA,EAAE,MACT,SAAUA,EAAE,IACZ,WACE,QAAC,eACC,oBAAC,UAAO,MAAM,WAAW,SAAU,IAAMK,EAAWL,CAAC,EAAG,KACxD,OAAC,UAAO,MAAM,mBAAmB,SAAU,IAAMQ,EAAYR,CAAC,EAAG,GACnE,GAPGA,EAAE,EAST,CACD,EAEL,CAEJ,CAEA,SAASS,GAAe,CACtB,SACE,OAAC,eACC,mBAAC,UAAO,MAAM,wBAAwB,SAAU,IAAM,CAAE,EAAG,EAC7D,CAEJ",
  "names": ["get_otp_exports", "__export", "Command", "__toCommonJS", "import_api", "import_react", "import_api", "import_crypto", "STORAGE_KEY", "loadPairs", "raw", "p", "seed", "seeded", "parseSeed", "savePairs", "pairs", "normalized", "generateId", "parseSeed", "text", "trimmed", "arr", "pairs", "x", "generateId", "p", "lines", "line", "m", "label", "ref", "dedupeByLabel", "dedupeByLabel", "pairs", "seen", "out", "p", "key", "generateId", "import_child_process", "import_util", "import_promises", "import_jsx_runtime", "execFileAsync", "runOpVersion", "opPath", "stdout", "readOtp", "ref", "e", "stderr", "fileExists", "path", "getOpPath", "prefs", "candidates", "c", "Command", "pairs", "setPairs", "checkingOp", "setCheckingOp", "opOk", "setOpOk", "setOpPath", "p", "version", "data", "loadPairs", "isLoading", "handleCopy", "pair", "code", "handlePaste", "EmptyActions"]
}
